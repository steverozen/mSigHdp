#' Extract (discover) mutational signatures from a matrix of mutational spectra
#'
#' Please see the vignette for an example.
#'
#' @inheritParams ParallelGibbsSample
#'
#' @inheritParams SaveAnalysis
#'
#' @inheritParams CombineChainsAndExtractSigs
#'
#' @inherit CombineChainsAndExtractSigs return
#'
#' @export

RunHdpxParallel <- function(input.catalog,
                            seedNumber           = 123,
                            K.guess,
                            multi.types          = FALSE,
                            verbose              = FALSE,
                            burnin               = 1000,
                            burnin.multiplier    = 10,
                            post.n               = 200,
                            post.space           = 100,
                            post.cpiter          = 3,
                            post.verbosity       = 0,
                            CPU.cores            = 20,
                            num.child.process    = 20,
                            high.confidence.prop = 0.9,
                            hc.cutoff           = 0.10,
                            overwrite           = TRUE,
                            out.dir             = NULL,
                            gamma.alpha         = 1,
                            gamma.beta          = 20,
                            checkpoint          = TRUE) {

  # Check for suitable version of hdpx
  if (utils::packageVersion("hdpx") < "0.3.9") {
    stop("hdpx version must be >= 0.3.9")
  }

  # Step 0: Get the input.catalog and keeping track of
  # whether it is an ICAMS catalog (encoded as an
  # additional class).
  input.catalog <- GetPossibleICAMSCatalog(input.catalog)

  # Step 1: Activate hierarchical Dirichlet processes and
  # run posterior sampling in parallel;
  # chlist is a list of hdpSampleChain-class objects.

  chlist <-
    ParallelGibbsSample(input.catalog,
                        seedNumber          = seedNumber,
                        K.guess             = K.guess,
                        multi.types         = multi.types,
                        verbose             = verbose,
                        burnin              = burnin,
                        post.n              = post.n,
                        post.space          = post.space,
                        post.cpiter         = post.cpiter,
                        post.verbosity      = post.verbosity,
                        CPU.cores           = CPU.cores,
                        num.child.process   = num.child.process,
                        gamma.alpha         = gamma.alpha,
                        gamma.beta          = gamma.beta,
                        burnin.multiplier   = burnin.multiplier,
                        checkpoint          = checkpoint)

  # For preparing test data
  if (FALSE) {
    save(chlist, file = "big.chlist.from.ParallelGibbsSample.Rdata")
  }

  # Step 2: Combine the posterior chains and extract
  # signatures and exposures;
  # retval has signatures, exposures, and multi.chains, a
  # hdpSampleMulti-class object.

  retval <-
    CombineChainsAndExtractSigs(chlist,
                                input.catalog  = input.catalog,
                                verbose        = verbose,
                                high.confidence.prop = high.confidence.prop,
                                hc.cutoff      = hc.cutoff)

  # Step 3: Save and plot signatures, exposures, diagnostics

  if(!is.null(out.dir)) {
    if (dir.exists(out.dir)) {
      if (!overwrite) stop(out.dir, " already exists")
      if (verbose) message("Using existing out.dir ", out.dir)
    } else {
      dir.create(out.dir, recursive = T)
      if (verbose) message("Created new out.dir ", out.dir)
    }
    save(retval, input.catalog, file = file.path(out.dir, "hdp.retval.Rdata"))
    SaveAnalysis(retval                = retval,
                 input.catalog         = input.catalog,
                 out.dir               = out.dir,
                 verbose               = verbose,
                 overwrite             = overwrite)
  }
  return(invisible(retval))
}

